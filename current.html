<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<title></title>
<!-- <link type="text/css" href="WebGL%20-%203D%20Camera%20Look%20At_files/jquery-ui-1.css" rel="stylesheet"> -->
<link type="text/css" href="WebGL%20-%203D%20Camera%20Look%20At_files/webgl-tutorials.css" rel="stylesheet">
<style>
#ui {
    width: 200px;
}
#rotation>canvas {
    background-color: rgba(255, 255, 255, 0.6) !important;
}
</style>
<script src="WebGL%20-%203D%20Camera%20Look%20At_files/jquery-1.js"></script>
<script src="WebGL%20-%203D%20Camera%20Look%20At_files/jquery-ui-1.js"></script>
<script src="WebGL%20-%203D%20Camera%20Look%20At_files/jquery.js"></script>
<script src="WebGL%20-%203D%20Camera%20Look%20At_files/webgl-utils.js"></script>
<script>
"use strict";

$(function()
{
  main();
});

function main()
{
  // Get A WebGL context
  var canvas = document.getElementById("canvas");
  var mousex,mousey,strikerx=0,strikery=0,velX=0,velY=0;
  var clicks=0,thrust=5,finalMouseX,finalMouseY;
  var move=false,dist=0,setPosition=false;
  var gl = getWebGLContext(canvas);
  if (!gl)
  {
    return;
  }

  //gl.enable(gl.CULL_FACE);
  gl.enable(gl.DEPTH_TEST);

  var program = createProgramFromScripts(gl, ["3d-vertex-shader", "3d-fragment-shader"]);
    gl.useProgram(program);

    // look up where the vertex data needs to go.
    var positionLocation = gl.getAttribLocation(program, "a_position");
    var colorLocation = gl.getAttribLocation(program, "a_color");

    // lookup uniforms
    var matrixLocation = gl.getUniformLocation(program, "u_matrix");

  // Create a buffer.
  var obj;
  function drawObject(matrix,vpmatrix,positions,colors,cnt_vertices,variable)
  {
    // setup GLSL program

    var buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.enableVertexAttribArray(positionLocation);
    gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);
    //var positions = setGeometry(gl);

    //alert(positions);
    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
    var buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.enableVertexAttribArray(colorLocation);
    gl.vertexAttribPointer(colorLocation, 3, gl.UNSIGNED_BYTE, true, 0, 0);
    //var colors=setColors(gl);

    //alert(colors);
    gl.bufferData(gl.ARRAY_BUFFER,colors,gl.STATIC_DRAW);


    matrix = matrixMultiply(matrix,vpmatrix);

    // Set the matrix.
    gl.uniformMatrix4fv(matrixLocation, false, matrix);

    // Draw the geometry.
    if(variable==1)
      gl.drawArrays(gl.TRIANGLES, 0, cnt_vertices);
    else
      gl.drawArrays(gl.LINES, 0, cnt_vertices);
  }

  function radToDeg(r)
  {
    return r * 180 / Math.PI;
  }

  function degToRad(d)
  {
    return d * Math.PI / 180;
  }

  var translation = [50, 400, 220];
  var rotation = [degToRad(0), degToRad(0), degToRad(0)];
  var scale = [1, 1, 1];
  var cameraAngleRadians = degToRad(0);
  var fieldOfViewRadians = degToRad(60);
  //drawScene();
  var canvas = document.getElementById('canvas');
  function getMousePos(canvas, evt) {
        var rect = canvas.getBoundingClientRect();
        return {
          x: evt.clientX - rect.left,
          y: evt.clientY - rect.top
        };
      }
  canvas.addEventListener('mousemove', function(event) {
  var mousePos = getMousePos(canvas, event);
  document.getElementById('myDiv').innerHTML = mousePos.x+' '+mousePos.y;
  mousex = mousePos.x;
  mousey = mousePos.y;
    finalMouseX=mousex;
    finalMouseY=mousey;
  });
  canvas.addEventListener('click', function(event) {
    clicks+=1;
    if(clicks%2==0)
    {
        strikerx = 190+(mousex*220)/600.0;
        strikery = 190;
    }
  });   
    
addEventListener('keydown', function (event) {
      if(event.keyCode==70)
      {
          move=true;
      }
  });
    
    
  setInterval(drawScene, 10);

  // addEventListener('keydown', function (event) {
  //   var dx,dy,rot,mx,my;
  //   dx=dy=mx=my=0;
  //   rot=Math.atan2(rotation[0],rotation[1])*180/Math.PI;
  //   var crot = radToDeg(cameraAngleRadians);
  //   if (event.keyCode == 87)
  //   {
  //     dy=-5.0;
  //   }
  //   else if(event.keyCode == 83)
  //   {
  //     dy+=5.0;
  //   }
  //   else if (event.keyCode == 65)
  //   {
  //     dx-=5.0;
  //   }
  //   else if(event.keyCode == 68)
  //   {
  //     dx+=5.0;
  //   }
  //   else if (event.keyCode == 37)
  //   {
  //     rot-=5.0;
  //   }
  //   else if(event.keyCode == 39)
  //   {
  //     rot+=5.0;
  //   }
  //   else if (event.keyCode == 38)
  //   {
  //     mx-=0.2;
  //   }
  //   else if(event.keyCode == 40)
  //   {
  //     mx+=0.2;
  //   }
  //   else if(event.keyCode == 66)
  //   {
  //     crot+=5;
  //   }
  //   else
  //   {
  //     return;
  //   }
  //   //alert(crot);
  //   translation[0]+=dx;
  //   translation[1]+=dy;
  //   rotation[0]=Math.sin(rot * Math.PI / 180);
  //   rotation[1]=Math.cos(rot * Math.PI / 180);
  //   scale[0]+=mx;
  //   cameraAngleRadians=degToRad(crot);
  //
  //   //drawScene();
  // });

  // Draw the scene.
  function computematrix(translation,rotation,scale)
  {

    var translationMatrix = makeTranslation(translation[0], translation[1], translation[2]);
    var rotationXMatrix = makeXRotation(rotation[0]);
    var rotationYMatrix = makeYRotation(rotation[1]);
    var rotationZMatrix = makeZRotation(rotation[2]);
    var scaleMatrix = makeScale(scale[0], scale[1], scale[2]);

    // Multiply the matrices.
    var matrix = matrixMultiply(scaleMatrix, rotationZMatrix);
    matrix = matrixMultiply(matrix, rotationYMatrix);
    matrix = matrixMultiply(matrix, rotationXMatrix);
    matrix = matrixMultiply(matrix, translationMatrix);

    return matrix;
  }
  var y=0;
  function drawScene()
  {

    // Clear the canvas AND the depth buffer.
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    // Compute the projection matrix
    var aspect = canvas.clientWidth / canvas.clientHeight;
    var projectionMatrix = makePerspective(fieldOfViewRadians, aspect, 1, 2000);

    // Use matrix math to compute a position on the circle.
    var cameraMatrix = makeTranslation(50, 0, 0);
    cameraMatrix = matrixMultiply( cameraMatrix, makeYRotation(cameraAngleRadians));
    cameraMatrix = matrixMultiply( cameraMatrix, makeTranslation(-150, 0, -360));

    // Get the camera's postion from the matrix we computed
    var cameraPosition = [
        cameraMatrix[12],
        cameraMatrix[13],
        cameraMatrix[14]];

    var up = [0, 1, 0];
    // console.log(cameraPosition);
    // Compute the camera's matrix using look at.
    var cameraMatrix = makeLookAt([-350,300,300], [0,300,300], up);
    // Make a view matrix from the camera matrix.
    var viewMatrix = makeInverse(cameraMatrix);
    var vpmatrix = matrixMultiply(viewMatrix,projectionMatrix);
    //var matrix = computematrix(translation,rotation,scale);

    //For board
    var matrix = computematrix([50,300,300],rotation,scale);
    var positions = getvertices_cuboid(10,300,300);
    var colors=getcolors_cuboid([254, 240, 195]);
    drawObject(matrix,vpmatrix,positions,colors,36,1);

    //For borders
    positions = getvertices_cuboid(20,20,340);
    colors = getcolors_cuboid([102,38,13]);
    //For left border
    matrix = computematrix([50,300,450+10],rotation,scale);
    drawObject(matrix,vpmatrix,positions,colors,36,1);
    //For right border
    matrix = computematrix([50,300,150-10],rotation,scale);
    drawObject(matrix,vpmatrix,positions,colors,36,1);
    //For top border
    matrix = computematrix([50,450+10,300],[degToRad(90),0,0],scale);
    drawObject(matrix,vpmatrix,positions,colors,36,1);
    //For bottom border
    matrix = computematrix([50,150-10,300],[degToRad(90),0,0],scale);
    drawObject(matrix,vpmatrix,positions,colors,36,1);

    //For striker borders
    positions = getvertices_cuboid(12,20,240);
    colors = getcolors_cuboid([0,0,0]);
    //For left border
    matrix = computematrix([50,300,400+10],rotation,scale);
    drawObject(matrix,vpmatrix,positions,colors,36,0);
    //For right border
    matrix = computematrix([50,300,200-10],rotation,scale);
    drawObject(matrix,vpmatrix,positions,colors,36,0);
    //For top border
    matrix = computematrix([50,400+10,300],[degToRad(90),0,0],scale);
    drawObject(matrix,vpmatrix,positions,colors,36,0);
    //For bottom border
    matrix = computematrix([50,200-10,300],[degToRad(90),0,0],scale);
    drawObject(matrix,vpmatrix,positions,colors,36,0);

    //For center
    positions = getvertices_cylinder(40,20,12);
    colors = getcolors_cylinder([0,0,0]);
    matrix = computematrix([54,300,300],rotation,scale);
    drawObject(matrix,vpmatrix,positions,colors,144,0);
    //For holes
    positions = getvertices_cylinder(12,20,18);
    colors = getcolors_cylinder([0,0,0]);

    matrix = computematrix([54,450-10,450-10],rotation,scale);
    drawObject(matrix,vpmatrix,positions,colors,216,1);
    matrix = computematrix([54,150+10,450-10],rotation,scale);
    drawObject(matrix,vpmatrix,positions,colors,216,1);
    matrix = computematrix([54,150+10,150+10],rotation,scale);
    drawObject(matrix,vpmatrix,positions,colors,216,1);
    matrix = computematrix([54,450-10,150+10],rotation,scale);
    drawObject(matrix,vpmatrix,positions,colors,216,1);
    //For striker
    if(clicks%2==0 && setPosition==false)
    {
        strikerx = 190+(mousex*220)/600.0;
        strikery = 190;
    }
    if(move==true)
        {
            setPosition=true;
            var tx = finalMouseX - strikerx, ty = finalMouseY - strikery;
            console.log('mouse',finalMouseX,finalMouseY);
            dist = Math.sqrt(tx*tx+ty*ty);
            var rad = Math.atan2(ty,tx),
            angle = rad/Math.PI * 180;
            velX = (dist/10)*Math.cos(rad);
            velY = (dist/10)*Math.sin(rad);
            console.log(dist,velX,velY);
            if(dist>1)
            {
                strikerx += velX;
                strikery += velY;
                document.getElementById('myDiv').innerHTML = strikerx+' '+strikery;
            }
            if(dist<1)
                {
                    setPosition=false;
                    move=false;
                }
        }
      
    positions = getvertices_cylinder(10,10,18);
    colors = getcolors_cylinder([3,120,213]);
    matrix = computematrix([44,strikery,strikerx],rotation,scale);
    drawObject(matrix,vpmatrix,positions,colors,216,1);
  }
}

function makeLookAt(cameraPosition, target, up) {
  var zAxis = normalize(
      subtractVectors(cameraPosition, target));
  var xAxis = cross(up, zAxis);
  var yAxis = cross(zAxis, xAxis);

  return [
     xAxis[0], xAxis[1], xAxis[2], 0,
     yAxis[0], yAxis[1], yAxis[2], 0,
     zAxis[0], zAxis[1], zAxis[2], 0,
     cameraPosition[0],
     cameraPosition[1],
     cameraPosition[2],
     1];
}

function subtractVectors(a, b) {
  return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];
}

function normalize(v) {
  var length = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
  // make sure we don't divide by 0.
  if (length > 0.00001) {
    return [v[0] / length, v[1] / length, v[2] / length];
  } else {
    return [0, 0, 0];
  }
}

function cross(a, b) {
  return [a[1] * b[2] - a[2] * b[1],
          a[2] * b[0] - a[0] * b[2],
          a[0] * b[1] - a[1] * b[0]];
}

function makePerspective(fieldOfViewInRadians, aspect, near, far) {
  var f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewInRadians);
  var rangeInv = 1.0 / (near - far);

  return [
    f / aspect, 0, 0, 0,
    0, f, 0, 0,
    0, 0, (near + far) * rangeInv, -1,
    0, 0, near * far * rangeInv * 2, 0
  ];
};

function getcolors_cuboid(col)
{
  var colors = new Uint8Array(108);
  for(var i=0;i<108;i+=3)
  {
    colors[i]=col[0];
    colors[i+1]=col[1];
    colors[i+2]=col[2];
  }
  return colors;
}

function getcolors_cylinder(col)
{
  var colors = new Uint8Array(648);
  for(var i=0;i<648;i+=3)
  {
    colors[i]=col[0];
    colors[i+1]=col[1];
    colors[i+2]=col[2];
  }
  return colors;
}


function makeTranslation(tx, ty, tz) {
  return [
     1,  0,  0,  0,
     0,  1,  0,  0,
     0,  0,  1,  0,
    tx, ty, tz,  1
  ];
}

function makeXRotation(angleInRadians) {
  var c = Math.cos(angleInRadians);
  var s = Math.sin(angleInRadians);

  return [
    1, 0, 0, 0,
    0, c, s, 0,
    0, -s, c, 0,
    0, 0, 0, 1
  ];
};

function makeYRotation(angleInRadians) {
  var c = Math.cos(angleInRadians);
  var s = Math.sin(angleInRadians);

  return [
    c, 0, -s, 0,
    0, 1, 0, 0,
    s, 0, c, 0,
    0, 0, 0, 1
  ];
};

function makeZRotation(angleInRadians) {
  var c = Math.cos(angleInRadians);
  var s = Math.sin(angleInRadians);
  return [
     c, s, 0, 0,
    -s, c, 0, 0,
     0, 0, 1, 0,
     0, 0, 0, 1,
  ];
}

function makeScale(sx, sy, sz) {
  return [
    sx, 0,  0,  0,
    0, sy,  0,  0,
    0,  0, sz,  0,
    0,  0,  0,  1,
  ];
}

function matrixMultiply(a, b)
{
  var mult = new Array(16).fill(0);
  for(var i=0;i<4;i++)
  {
    for(var j=0;j<4;j++)
    {
      for(var k=0;k<4;k++)
      {
        mult[4*i+j]+=a[4*i+k]*b[4*k+j];
      }
    }
  }
  return mult;
}

function makeInverse(m)
{

  var inv = new Array(16);

  inv[0] = m[5]*m[10]*m[15] - m[5]*m[14]*m[11] - m[6]*m[9]*m[15] + m[6]*m[13]*m[11] + m[7]*m[9]*m[14] - m[7]*m[13]*m[10];
  inv[1] = -m[1]*m[10]*m[15] + m[1]*m[14]*m[11] + m[2]*m[9]*m[15] - m[2]*m[13]*m[11] - m[3]*m[9]*m[14] + m[3]*m[13]*m[10];
  inv[2] = m[1]*m[6]*m[15] - m[1]*m[14]*m[7] - m[2]*m[5]*m[15] + m[2]*m[13]*m[7] + m[3]*m[5]*m[14] - m[3]*m[13]*m[6];
  inv[3] = -m[1]*m[6]*m[11] + m[1]*m[10]*m[7] + m[2]*m[5]*m[11] - m[2]*m[9]*m[7] - m[3]*m[5]*m[10] + m[3]*m[9]*m[6];

  inv[4] = -m[4]*m[10]*m[15] + m[4]*m[14]*m[11] + m[6]*m[8]*m[15] - m[6]*m[12]*m[11] - m[7]*m[8]*m[14] + m[7]*m[12]*m[10];
  inv[5] = m[0]*m[10]*m[15] - m[0]*m[14]*m[11] - m[2]*m[8]*m[15] + m[2]*m[12]*m[11] + m[3]*m[8]*m[14] - m[3]*m[12]*m[10];
  inv[6] = -m[0]*m[6]*m[15] + m[0]*m[14]*m[7] + m[2]*m[4]*m[15] - m[2]*m[12]*m[7] - m[3]*m[4]*m[14] + m[3]*m[12]*m[6];
  inv[7] = m[0]*m[6]*m[11] - m[0]*m[10]*m[7] - m[2]*m[4]*m[11] + m[2]*m[8]*m[7] + m[3]*m[4]*m[10] - m[3]*m[8]*m[6];

  inv[8] = m[4]*m[9]*m[15] - m[4]*m[13]*m[11] - m[5]*m[8]*m[15] + m[5]*m[12]*m[11] + m[7]*m[8]*m[13] - m[7]*m[12]*m[9];
  inv[9] = -m[0]*m[9]*m[15] + m[0]*m[13]*m[11] + m[1]*m[8]*m[15] - m[1]*m[12]*m[11] - m[3]*m[8]*m[13] + m[3]*m[12]*m[9];
  inv[10] = m[0]*m[5]*m[15] - m[0]*m[13]*m[7] - m[1]*m[4]*m[15] + m[1]*m[12]*m[7] + m[3]*m[4]*m[13] - m[3]*m[12]*m[5];
  inv[11] = -m[0]*m[5]*m[11] + m[0]*m[9]*m[7] + m[1]*m[4]*m[11] - m[1]*m[8]*m[7] - m[3]*m[4]*m[9] + m[3]*m[8]*m[5];

  inv[12] = -m[4]*m[9]*m[14] + m[4]*m[13]*m[10] + m[5]*m[8]*m[14] - m[5]*m[12]*m[10] - m[6]*m[8]*m[13] + m[6]*m[12]*m[9];
  inv[13] = m[0]*m[9]*m[14] - m[0]*m[13]*m[10] - m[1]*m[8]*m[14] + m[1]*m[12]*m[10] + m[2]*m[8]*m[13] - m[2]*m[12]*m[9];
  inv[14] = -m[0]*m[5]*m[14] + m[0]*m[13]*m[6] + m[1]*m[4]*m[14] - m[1]*m[12]*m[6] - m[2]*m[4]*m[13] + m[2]*m[12]*m[5];
  inv[15] = m[0]*m[5]*m[10] - m[0]*m[9]*m[6] - m[1]*m[4]*m[10] + m[1]*m[8]*m[6] + m[2]*m[4]*m[9] - m[2]*m[8]*m[5];

  var det = m[0]*inv[0] + m[1]*inv[4] + m[2]*inv[8] + m[3]*inv[12];
  for (var i = 0; i < 16; i++)
  {
    inv[i] /= det;
  }
  return inv;

}

function matrixVectorMultiply(v, m) {
  var dst = [];
  for (var i = 0; i < 4; ++i) {
    dst[i] = 0.0;
    for (var j = 0; j < 4; ++j)
      dst[i] += v[j] * m[j * 4 + i];
  }
  return dst;
};


function getvertices_cuboid(L,B,H)
{
  L = L/2;
  B = B/2;
  H = H/2;
  return new Float32Array([
        //Front Face
        -L, -H,  B,
        L, -H,  B,
        L,  H,  B,
        L,  H,  B,
        -L,  H,  B,
        -L, -H,  B,
        //Back Face
        -L, -H, -B,
        L, -H, -B,
        L,  H, -B,
        L,  H, -B,
        -L,  H, -B,
        -L, -H, -B,
        //left Face
        -L, -H,  B,
        -L, -H, -B,
        -L,  H, -B,
        -L,  H, -B,
        -L,  H,  B,
        -L, -H,  B,
        //right Face
        L, -H,  B,
        L, -H, -B,
        L,  H, -B,
        L,  H, -B,
        L,  H,  B,
        L, -H,  B,
        //Top Face
        -L,  H,  B,
        -L,  H, -B,
        L,  H, -B,
        L,  H, -B,
        L,  H,  B,
        -L,  H,  B,
        //Bottom Face
        -L, -H,  B,
        -L, -H, -B,
        L, -H, -B,
        L, -H, -B,
        L, -H,  B,
        -L, -H,  B

    ]);
}

function getvertices_cylinder(R,H,n)
{
  function degToRad(d)
  {
    return d * Math.PI / 180;
  }
  var vertices = new Float32Array(36*n);
  var addangle = 360/n;
  var angle = 0;
  var pointer = 0;
  for(var i=0;i<n;i+=1)
  {
    vertices[pointer+0] = -H/2;
    vertices[pointer+1] = 0;
    vertices[pointer+2] = 0;
    vertices[pointer+3] = -H/2;
    vertices[pointer+4] = R*Math.sin(degToRad(angle));
    vertices[pointer+5] = R*Math.cos(degToRad(angle));
    vertices[pointer+6] = -H/2;
    vertices[pointer+7] = R*Math.sin(degToRad(angle+addangle));
    vertices[pointer+8] = R*Math.cos(degToRad(angle+addangle));

    vertices[pointer+9] = H/2;
    vertices[pointer+10] = 0;
    vertices[pointer+11] = 0;
    vertices[pointer+12] = H/2;
    vertices[pointer+13] = R*Math.sin(degToRad(angle));
    vertices[pointer+14] = R*Math.cos(degToRad(angle));
    vertices[pointer+15] = H/2;
    vertices[pointer+16] = R*Math.sin(degToRad(angle+addangle));
    vertices[pointer+17] = R*Math.cos(degToRad(angle+addangle));

    vertices[pointer+18] = vertices[pointer+3];
    vertices[pointer+19] = vertices[pointer+4];
    vertices[pointer+20] = vertices[pointer+5];
    vertices[pointer+21] = vertices[pointer+6];
    vertices[pointer+22] = vertices[pointer+7];
    vertices[pointer+23] = vertices[pointer+8];
    vertices[pointer+24] = vertices[pointer+12];
    vertices[pointer+25] = vertices[pointer+13];
    vertices[pointer+26] = vertices[pointer+14];

    vertices[pointer+27] = vertices[pointer+12];
    vertices[pointer+28] = vertices[pointer+13];
    vertices[pointer+29] = vertices[pointer+14];
    vertices[pointer+30] = vertices[pointer+15];
    vertices[pointer+31] = vertices[pointer+16];
    vertices[pointer+32] = vertices[pointer+17];
    vertices[pointer+33] = vertices[pointer+6];
    vertices[pointer+34] = vertices[pointer+7];
    vertices[pointer+35] = vertices[pointer+8];
    pointer += 36;
    angle += addangle;
  }
  return vertices;
}
// Fill the buffer with colors for the 'F'.
</script>
<!-- vertex shader -->
<script id="3d-vertex-shader" type="x-shader/x-vertex">
  attribute vec4 a_position;
  attribute vec4 a_color;

  uniform mat4 u_matrix;

  varying vec4 v_color;

  void main()
  {
    // Multiply the position by the matrix.
    gl_Position = u_matrix * a_position;

    // Pass the color to the fragment shader.
    v_color = a_color;
  }
</script>
<!-- fragment shader -->
<script id="3d-fragment-shader" type="x-shader/x-fragment">
  precision mediump float;

  // Passed in from the vertex shader.
  varying vec4 v_color;

  void main() {
     gl_FragColor = v_color;
  }
</script>
</head>
<body>

<canvas id="canvas" width="600" height="600"></canvas>
<p id="myDiv"></p>
<div id="uiContainer">
  <div id="ui">
    <div id="cameraAngle"><div class="gman-slider-outer"><div class="gman-slider-upper"><div class="gman-slider-label">cameraAngle</div><div class="gman-slider-value">-360</div></div><div class="gman-slider-slider ui-slider ui-slider-horizontal ui-widget ui-widget-content ui-corner-all"><a style="left: 0%;" class="ui-slider-handle ui-state-default ui-corner-all ui-state-focus" href="#"></a></div></div></div>
  </div>
</div>
</body></html>

